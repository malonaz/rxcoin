In this section we will discuss how we maintain privacy on a public distributed ledger purely technologically.
We will encode sensitive information using cryptographic hash functions, also called compression functions. We call the image of a data input the hash of the input.
In order for our hash function to be mathematically secure, we will include several key properties in its definition.\\

Definition of a cryptographically secure hash function:\\
Let f be a function on strings to strings.Then f is a cryptographically secure function if:\\
  1)f is efficiently computable;
  2)f is collison-resistant
  3)f is hiding;
  4)f is puzzle-friendly;\\
  
Property 1 is essential if we want a useful i.e not computationally expensive function to use over big data inputs. Property 2 is injectivity: nobody can find two distinct inputs x and y map to the same hashes.This ensures no information is lost whilst applying the hash function hence the denomination "compression".
Property 3 is non-invertibility: nobody can deduce the original input x from its hash. This ensures secure encoding of the sensitive inputs into hashes.
Property 4 is non-targetability: given a part of a hash y and part of its input x, nobody can find the complete input x whose hash is y. This computational difficulty will be central to mining, which we will discuss in an ulterior section.
When we mean "nobody", we mean all third-parties without access to secret keys of the user.\\

Technically speaking, compression functions only have fixed sized outputs but we can extend the output-range to strings of any size using a Merkle-Damgard transform but all the security properties of the underlying function are transfered to the global function so we're fine.\\

Now, how might we put our hash functions to good use? We first need to define a new type of datastructure: a blockchain.

