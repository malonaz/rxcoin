\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Blockchain for RxCoin}
\author{linden.sovann }
\date{February 2018}

\begin{document}

\maketitle

\section{Hash functions}


In this section we will discuss how we maintain privacy on a public distributed ledger purely technologically.
We will encode sensitive information using cryptographic hash functions, also called compression functions. We call the image of a data input the hash of the input.
In order for our hash function to be mathematically secure, we will include several key properties in its definition.\\

Definition of a cryptographically secure hash function:\\
Let f be a function on strings to strings.Then f is a cryptographically secure function if:\\
  1)f is efficiently computable;
  2)f is collison-resistant
  3)f is hiding;
  4)f is puzzle-friendly;\\
  
Property 1 is essential if we want a useful i.e not computationally expensive function to use over big data inputs. Property 2 is injectivity: nobody can find two distinct inputs x and y map to the same hashes.This ensures no information is lost whilst applying the hash function hence the denomination "compression".\\
Property 3 is non-invertibility: nobody can deduce the original input x from its hash. This ensures secure encoding of the sensitive inputs into hashes.
Property 4 is non-targetability: given a part of a hash y and part of its input x, nobody can find the complete input x whose hash is y. This computational difficulty will be central to mining, which we will discuss in an ulterior section.
When we mean "nobody", we mean all third-parties without access to secret keys of the user.\\

Technically speaking, compression functions only have fixed sized outputs but we can extend the output-range to strings of any size using a Merkle-Damgard transform but all the security properties of the underlying function are transfered to the global function so we're fine.\\

Now, how might we put our hash functions to good use? We first need to define a new type of datastructure: a blockchain.\\ 
\\
\\

\section{Basic blockchain}
A blockchain is a chain of blocks. What is a block and how do you chain them together? A block is data consisting of a set of transactions and hash pointers. A transaction consists of information about the sender, the recipient and amount of RxCoin to be transfered. For more details on block optimisation, see the advanced blocks section. Now, we link these blocks together using hash pointers. Hash pointers reference a location where some data is stored together with the hash of that data.
Hence, if we consider the latest block of the chain, this will give us the current state of RxCoin accounts i.e the distribution of money in different RxCoin wallets. Any RxCoin user can view the history of transactions by looking back across the chain; the blockchain essentially constitues a ledger of all past transactions. Since the latest block contains a pointer to where the previous block was, we don't need to store the whole blockchain: we can recover it from the most current value, making blockchain an efficient way of recording data.\
Image of a blockchain here:\ % insert image % 
\\

Now consider an adversary trying tamper data in the blockchain. The adversary will modify data in a given block. But then the hash pointer of the previous block will not match up with the new modified data, given collision-resistance of our hash function. Hence the adversary will need to modify the next block as well and so on until he hits the genesis block, which users will monitor and so the tampering will be detected. Therefore, any modification, however minor, propagates throughout the entire blockchain to the most genesis block and is immediately detected. We can say that the blockchain is the ultimate fault-tolerant ledger. This is particularly important for financial transactions but even more so in the healthcare industry where inaccurate records cause each year cost $x$ lives in the US alone.
 % put amount % 
 \\
 
Now, the fact that RxCoin relies on a decentralised  raises some issues for RxChain. Each time a transaction is initiated, it risks being invalid i.e adding coins to one's wallet without anyone sending you the coins. Remember we can view the distribution of RxCoin on the RxChain as collection of states, or a global state. Making a non-trivial transaction changes that global state. The transition between these two states is a high-dimensional path. Thinking geometrically, we want to travel on valid paths and detect invalid paths. This must be done in a decentralised way so that no one entity controls the transactions and thus achieved through a distributed consensus protocol. Distributed consensus protocols require work or "mining" to be done to maintain the blockchain. In the next sections, we'll explore different mining architectures, their implications on latency, tolerance and on the value of RxCoin

\section{Mining architecture: Proof of Work}
In this section, miners will also be referred to as nodes, the graph all nodes is called the RxCoin network.At any given point,each node has two sets of information: a ledger of blocks on which they have reached a consensus and an outstanding "pool" of blocks that have not yet been validated by the network. We will assume 
Say Alice wants to perform a transaction.We assume Alice honest. Then Alice broadcasts the transaction to whole RxCoin network. Some nodes "hear" about Alice's broadcast and her transaction enters the oustanding "pool" of these nodes.
Then, every $x$ minutes, a node is randomly selected and broadcasts a block containing Alice's transaction. The other nodes accept the block only if it is valid. They accept the block by including its hash in the next block they create. If the randomly selected node is malicious,its block is not built upon and another randomly selected node's block will be favoured. The blockchain consists of the longest chain i.e the most accepted version of all transactions. \\

In this scenario, we have made two assumptions: that Alice is honest and that the majority of nodes are honest. 
Let's test these assumptions. If Alice was not honest,and say tried to steal RxCoins then if a node includes her transaction in a block this is equivalent to the above scenario with a malicious node. \\


Now let's turn to the problem of the majority of nodes being honest, also named the Byzantine Fault-Tolerance problem.
To illustrate this problem, consider if 51-percent of nodes were malicious. Then, because the decentralised protocol consensus relies on selecting randomly proposed options until a majority agrees (remember longest chain), a malicious majority could allow invalid transactions to happen.
Hence there are two systems to incentivise nodes to be honest: rewards and punishments.\\

Rewards come in two forms: RxCoin tokens and 
The higher the dollar exchange rate, the greater the incentive.
However, if we distribute too generously RxCoin, we risk devaluing it by conducting an inflationary policy.
Hence we must limit the supply of RxCoins and typically after a number of initial coins in circulation, the number of new coins issued should decrease pseudo-exponentially each year. We also have to limit the demand for mined RxCoins by introducing capital hurdles to the mining activity, this is through mathematical puzzles: this is called proof-of-work (PoW).\\

PoW must have problems that are hard to solve but with easily validated  solutions– in other words PoW relies on NP-hard computational puzzles.
The way PoW works is the following: the random selection of nodes is actually skewed in favour of those with greater computing power. Indeed, the first node to have solved the puzzle is allowed to broadcast their block, giving weight to technological advantage. At a certain level of difficulty , puzzles will be solved as fast on a PC than on specialised hardware. However, if we increase the level of difficulty as the number of miners increase and the supply of RxCoin diminishes, the upfront capital costs required by hardware upgrades will render small miners uncompetitive. This risks driving a centralisation of mining and thus jeopardise the decentralised nature of RxCoin's network, making it vulnerable to 51-percent attacks– i.e majority controlled by a malicious nodes.\\

To alleviate this, we can implement "punishments" for malicious nodes or modify the type of puzzle so its solving is less specialized-hardware dependent. We will not go at lenght into these solutions and instead discuss another mining architecture: Proof of Stake.\\

\section{Mining architecture: Proof of Stake}
-Different concept
-Advantages environment
-Faster
-Security concerns


Hence, we can sketch out a product development timeline. Initially, we would design RxCoin's mining architecture as a simple PoW system. This will ensure the early development of RxCoin by guaranteeing miners seizable financial incentives and thus establishing a core mining community. In turn, RxCoin will be seen as trustworthy, reliable and will gain visibiliy in the cryptocurrency world, thus hastening the pace of user acquisition. When the number of miners increase and as our supply of new coins diminishes much faster than the price increase, we will have to increase the computational complexity of our puzzles. Then, when it becomes uncompetitive for small miners to continue validating blocks, we will upgrade to an ASIC-proof PoW to avoid excessive mining centralisation. Eventually, we would migrate to a mixed PoW/PoS system.

\section{Advanced blocks}
Why do we group transactions into blocks, why can't we just see individual transactions as blocks?
\section{Graph theory and scalability}
Blockchains are basically just directed graphs i.e vertices linked by pointers that flow in one direction. However, these graphs one important property: they are acyclic. Indeed, they cannot contain any loops because we need an objective genesis for validation procedures to be well-defined. Such graphs are also called trees. Nonetheless, thanks to these constraints, we analyse and construct the best blockchains from both a security and a computational perspective by doing some advanced graph theory.
Merkle trees and proof of membership
Merkle Patricia trees
Modified Merkle Patricia trees

  
\end{document}
