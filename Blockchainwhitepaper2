\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Blockchain for RxCoin}
\author{linden.sovann }
\date{February 2018}

\begin{document}

\maketitle

\section{Hash functions}


In this section we will discuss how we maintain privacy on a public distributed ledger purely technologically.
We will encode sensitive information using cryptographic hash functions, also called compression functions. We call the image of a data input the hash of the input.
In order for our hash function to be mathematically secure, we will include several key properties in its definition.\\

Definition of a cryptographically secure hash function:\\
Let f be a function on strings to strings.Then f is a cryptographically secure function if:\\
  1)f is efficiently computable;
  2)f is collison-resistant
  3)f is hiding;
  4)f is puzzle-friendly;\\
  
Property 1 is essential if we want a useful i.e not computationally expensive function to use over big data inputs. Property 2 is injectivity: nobody can find two distinct inputs x and y map to the same hashes.This ensures no information is lost whilst applying the hash function hence the denomination "compression".
Property 3 is non-invertibility: nobody can deduce the original input x from its hash. This ensures secure encoding of the sensitive inputs into hashes.
Property 4 is non-targetability: given a part of a hash y and part of its input x, nobody can find the complete input x whose hash is y. This computational difficulty will be central to mining, which we will discuss in an ulterior section.
When we mean "nobody", we mean all third-parties without access to secret keys of the user.\\

Technically speaking, compression functions only have fixed sized outputs but we can extend the output-range to strings of any size using a Merkle-Damgard transform but all the security properties of the underlying function are transfered to the global function so we're fine.\\

Now, how might we put our hash functions to good use? We first need to define a new type of datastructure: a blockchain.

\section{Basic blockchain}
A blockchain is a chain of blocks. What is a block and how do you chain them together? A block is data consisting of a set of transactions and hash pointers. A transaction consists of information about the sender, the recipient and amount of RxCoin to be transfered. For more details on blocks, see the advanced blocks section. Now, we link these blocks together using hash pointers. Hash pointers reference a location where some data is stored together with the hash of that data.
Hence, if we consider the latest block of the chain, this will give us the current state of RxCoin accounts i.e the distribution of money in different RxCoin wallets. Any RxCoin user can view the history of transactions by looking back across the chain; the blockchain essentially constitues a ledger of all past transactions. Since the latest block contains a pointer to where the previous block was, we don't need to store the whole blockchain: we can recover it from the most current value, making blockchain an efficient way of recording data.\
Image of a blockchain here:\ % insert image % 

Now consider an adversary trying tamper data in the blockchain. The adversary will modify data in a given block. But then the hash pointer of the previous block will not match up with the new modified data, given collision-resistance of our hash function. Hence the adversary will need to modify the next block as well and so on until he hits the genesis block, which users will monitor and so the tampering will be detected. Therefore, any modification, however minor, propagates throughout the entire blockchain to the most genesis block and is immediately detected. We can say that the blockchain is the ultimate fault-tolerant ledger. This is particularly important for financial transactions but even more so in the healthcare industry where inaccurate records cause each year cost $x$ lives in the US alone.
 % put amount % 
Now, the fact that RxCoin relies on a decentralised  raises some issues for RxChain. Each time a transaction is initiated, it risks being invalid i.e adding coins to one's wallet without anyone sending you the coins. Remember we can view the distribution of RxCoin on the RxChain as collection of states, or a global state. Making a non-trivial transaction changes that global state. The transition between these two states is a high-dimensional path. Thinking geometrically, we want to travel on valid paths and detect invalid paths. This must be done in a decentralised way so that no one entity controls the transactions and thus achieved through a distributed consensus protocol. Distributed consensus protocols require work or "mining" to be done to maintain the blockchain. In the next sections, we'll explore different mining architectures and how they would affect RxCoin as a whole.

\section{Mining architecture}
\section{Incentives, supply and resilience}
\section{Advanced blocks}
Why do group transactions into blocks, why can't we just see individual transactions as blocks?
\section{Graph theory and scalability}
Blockchains are basically just directed graphs i.e vertices linked by pointers that flow in one direction. However, these graphs one important property: they are acyclic. Indeed, they cannot contain any loops because we need an objective genesis for validation procedures to be well-defined. Such graphs are also called trees. Nonetheless, thanks to these constraints, we analyse and construct the best blockchains from both a security and a computational perspective by doing some advanced graph theory.
Merkle trees and proof of membership
Merkle Patricia trees
Modified Merkle Patricia trees

  
\end{document}
